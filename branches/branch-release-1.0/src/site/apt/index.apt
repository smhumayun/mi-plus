About Project MI+

    Project MI+ is all about making Java's Multiple <Interface> Inheritance more "<<adaptable>>" and in doing so, it
    will help you achieve multiple inheritance (functionally) with lesser amount of code and maintenance. Read more
    about the {{{./motivation.html}Motivation behind Project MI+}}

Getting Started

    Suppose we want to inherit our <<<Child>>> class from two parent classes: (1) <<<ParentOne>>> and
    (2) <<<ParentTwo>>>.

+---
public class ParentOne {
    public void parentOneMethod() {
        System.out.println("parent one method");
    }
}

public class ParentTwo {
    public void parentTwoMethod() {
        System.out.println("parent two method");
    }
}
+---

    The closest emulation of Multiple (Implementation) Inheritance in Java, can be done, using (1). Multiple <Interface>
    Inheritance, (2). Objection Composition and (3). Method Delegation, as follows:

+---
public interface ParentOne {
    void parentOneMethod();
}

public interface ParentTwo {
    public void parentTwoMethod();
}

public class ParentOneImpl implements ParentOne {
    @override
    public void parentOneMethod() {
        System.out.println("parent one method");
    }
}

public class ParentTwoImpl implements ParentTwo {
    @Override
    public void parentTwoMethod() {
        System.out.println("parent two method");
    }
}

public interface ChildOne extends ParentOne, ParentTwo { //(1). multiple interface inheritance
}

public class ChildOneImpl implements Child1 {

    private ParentOneImpl delegateParentOneImpl; //(2). object composition
    private ParentTwoImpl delegateParentTwoImpl; //(2). object composition

    @override
    public void parentOneMethod() {
        delegateParentOneImpl.parentOneMethod(); //(3). method delegation
    }

    @override
    public void parentTwoMethod() {
        delegateParentTwoImpl.parentTwoMethod(); //(3). method delegation
    }

}
+---

    Using Project MI+, we can define the same <<<ChildOne>>> with lesser amount of code, as follows:

+---
import com.smhumayun.mi_plus.MISupport;

@MISupport(parentClasses = {ParentOneImpl.class, ParentTwoImpl.class})
public interface ChildTwo extends ParentOne, ParentTwo {
}
+---

    For multiple inheritance to work, you should always create new instances of <<<MISupport>>>
    ({{{./apidocs/com/smhumayun/mi_plus/MISupport.html}JavaDoc}}
    | {{{./xref/com/smhumayun/mi_plus/MISupport.html}Source Code}})
    annotated classes (only)
    via <<<MIFactory>>>
    ({{{./apidocs/com/smhumayun/mi_plus/MIFactory.html}JavaDoc}}
    | {{{./xref/com/smhumayun/mi_plus/MIFactory.html}Source Code}})
    instead of directly instantiating them using java's <<<new>>> keyword and a constructor.

+---
import com.smhumayun.mi_plus.MIFactory;

...
    MIFactory miFactory = new MIFactory();
    ChildTwo childTwo = miFactory.newInstance(Child.class);
    childTwo.parentOneMethod();
    childTwo.parentTwoMethod();
...
+---

    The <<<childTwo>>> now refers to an object which <(functionally)> inherits methods from all the parent classes.

    Most importantly, if you add a new method, or update the signature of existing method or remove any existing method,
    from either of the parents, those changes will be reflected automatically in the <<<ChildTwo>>>, but the very same
    changes will break <<<ChildOne>>>. Why? {{{./motivation.html} read more here}}.

What's Next?

    {{{./validation.html}Eager vs Lazy Validation}}